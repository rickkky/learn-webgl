// 1/main.ts 

import '../../../src/style.css';
import { resizeCanavsToDisplaySize, createProgram } from '../../../src/helper';
import vertexShaderSource from './vertex.glsl';
import fragmentShaderSource from './fragment.glsl';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const gl = canvas.getContext('webgl2')!;

// Make the canvas the same size as the display size.
resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

// Clear the canvas.
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);

// Create a program.
const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
// Set it as the current program.
gl.useProgram(program);

// Create a vertex array object.
const vao = gl.createVertexArray();
// And make it the one we're currently working with.
gl.bindVertexArray(vao);
// Get the location of the `a_position` attribute in the vertex shader.
const positionLocation = gl.getAttribLocation(program, 'a_position');
// Turn on the attribute
gl.enableVertexAttribArray(positionLocation);
// Create a buffer.
const positionBuffer = gl.createBuffer();
// Bind it to `ARRAY_BUFFER` bind point.
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
// Specify how to pull the data out of the buffer.
// It implicitly binds the current `ARRAY_BUFFER` to the attribute.
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
// Vertex data.
const positions = [0, 0, 0, 0.5, 0.7, 0];
// Put the data in the buffer.
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

// Render primitives from array data by executing the shader program.
gl.drawArrays(gl.TRIANGLES, 0, 3);

// --

#version 300 es

in vec4 a_position;

void main() {
  gl_Position = a_position;
}

// --

#version 300 es

precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(1, 0, 0, 1);
}

// --

import '../../../src/style.css';
import { resizeCanavsToDisplaySize, createProgram } from '../../../src/helper';
import vertexShaderSource from './vertex.glsl';
import fragmentShaderSource from './fragment.glsl';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const gl = canvas.getContext('webgl2')!;

resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);

const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
gl.useProgram(program);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
const positions = [0, 0.6, 0.6, -0.6, -0.6, -0.6];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

gl.drawArrays(gl.TRIANGLES, 0, 3);


// --

#version 300 es

in vec4 a_position;

out vec4 v_color;

void main() {
  gl_Position = a_position;

  v_color = vec4((gl_Position * 0.5 + 0.5).xy, 0.5, 1);
}

// --

#version 300 es

precision highp float;

in vec4 v_color;

out vec4 outColor;

void main() {
  outColor = v_color;
}

// --
import '../../../src/style.css';
import { resizeCanavsToDisplaySize, createProgram } from '../../../src/helper';
import vertexShaderSource from './vertex.glsl';
import fragmentShaderSource from './fragment.glsl';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const gl = canvas.getContext('webgl2')!;

resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);

const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
gl.useProgram(program);

const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

const colorLocation = gl.getUniformLocation(program, 'u_color');

for (let i = 0; i < 50; i++) {
  const x0 = Math.random() * gl.canvas.width;
  const y0 = Math.random() * gl.canvas.height;
  const x1 = Math.random() * gl.canvas.width;
  const y1 = Math.random() * gl.canvas.height;
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([x0, y0, x0, y1, x1, y0, x0, y1, x1, y1, x1, y0]),
    gl.STATIC_DRAW,
  );
  gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
}
