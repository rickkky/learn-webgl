diff --git a/demo/first-triangle/index.html b/demo/first-triangle/index.html
index 1aa76ca..6b6353e 100644
--- a/demo/first-triangle/index.html
+++ b/demo/first-triangle/index.html
@@ -5,6 +5,7 @@
     <link rel="icon" type="image/svg+xml" href="/icon.svg" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>First Triangle</title>
+    <link rel="stylesheet" href="/common/style.css" />
   </head>
   <body>
     <div id="app">
diff --git a/demo/first-triangle/src/main.ts b/demo/first-triangle/src/main.ts
index 88064c6..dcf9d59 100644
--- a/demo/first-triangle/src/main.ts
+++ b/demo/first-triangle/src/main.ts
@@ -1,4 +1,3 @@
-import '/common/style.css';
 import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
 import vertexShaderSource from './vertex.glsl';
 import fragmentShaderSource from './fragment.glsl';
@@ -19,10 +18,13 @@ const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
 // Set it as the current program.
 gl.useProgram(program);
 
-// Create a vertex array object.
+// Create a vertex array object
+// which represents a set of vertex data;
 const vao = gl.createVertexArray();
 // And make it the one we're currently working with.
+// Calls to `bindBuffer` or `vertexAttribPointer` will be "recorded" in the VAO.
 gl.bindVertexArray(vao);
+
 // Get the location of the `a_position` attribute in the vertex shader.
 const positionLocation = gl.getAttribLocation(program, 'a_position');
 // Turn on the attribute
@@ -31,13 +33,13 @@ gl.enableVertexAttribArray(positionLocation);
 const positionBuffer = gl.createBuffer();
 // Bind it to `ARRAY_BUFFER` bind point.
 gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
-// Specify how to pull the data out of the buffer.
-// It implicitly binds the current `ARRAY_BUFFER` to the attribute.
-gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
 // Vertex data.
 const positions = [0, 0, 0, 0.5, 1, 0];
 // Put the data in the buffer.
 gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+// Specify how to pull the data out of the buffer.
+// It implicitly binds the current `ARRAY_BUFFER` to the attribute.
+gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
 
 // Render primitives from array data by executing the shader program.
 gl.drawArrays(gl.TRIANGLES, 0, 3);
diff --git a/demo/gradiant-triangle/index.html b/demo/gradiant-triangle/index.html
index c4902f7..7c61475 100644
--- a/demo/gradiant-triangle/index.html
+++ b/demo/gradiant-triangle/index.html
@@ -5,6 +5,7 @@
     <link rel="icon" type="image/svg+xml" href="/icon.svg" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>Gradiant Triangle</title>
+    <link rel="stylesheet" href="/common/style.css" />
   </head>
   <body>
     <div id="app">
diff --git a/demo/gradiant-triangle/src/main.ts b/demo/gradiant-triangle/src/main.ts
index b01a842..9113720 100644
--- a/demo/gradiant-triangle/src/main.ts
+++ b/demo/gradiant-triangle/src/main.ts
@@ -1,4 +1,3 @@
-import '/common/style.css';
 import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
 import vertexShaderSource from './vertex.glsl';
 import fragmentShaderSource from './fragment.glsl';
@@ -15,8 +14,8 @@ gl.clear(gl.COLOR_BUFFER_BIT);
 const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
 gl.useProgram(program);
 
-// const vao = gl.createVertexArray();
-// gl.bindVertexArray(vao);
+const vao = gl.createVertexArray();
+gl.bindVertexArray(vao);
 
 const positionLocation = gl.getAttribLocation(program, 'a_position');
 gl.enableVertexAttribArray(positionLocation);
diff --git a/demo/image-processing-pro/index.html b/demo/image-processing-pro/index.html
new file mode 100644
index 0000000..8ce004e
--- /dev/null
+++ b/demo/image-processing-pro/index.html
@@ -0,0 +1,17 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Simple Texture</title>
+    <link rel="stylesheet" href="/common/style.css" />
+  </head>
+  <body>
+    <div id="app">
+      <canvas id="canvas"></canvas>
+    </div>
+    <script type="module" src="/common/home.ts"></script>
+    <script type="module" src="./src/main.ts"></script>
+  </body>
+</html>
diff --git a/demo/image-processing-pro/src/fragment.glsl b/demo/image-processing-pro/src/fragment.glsl
new file mode 100644
index 0000000..fad10b7
--- /dev/null
+++ b/demo/image-processing-pro/src/fragment.glsl
@@ -0,0 +1,28 @@
+#version 300 es
+
+precision highp float;
+
+uniform sampler2D u_image;
+uniform float u_kernel[9];
+uniform float u_kernelWeight;
+
+in vec2 v_texCoord;
+
+out vec4 outColor;
+
+void main() {
+  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));
+
+  vec4 colorSum = 
+    texture(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +
+    texture(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +
+    texture(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;
+
+  outColor = vec4((colorSum / u_kernelWeight).rgb, 1);
+}
diff --git a/demo/image-processing-pro/src/leaves.jpg b/demo/image-processing-pro/src/leaves.jpg
new file mode 100644
index 0000000..529b94e
Binary files /dev/null and b/demo/image-processing-pro/src/leaves.jpg differ
diff --git a/demo/image-processing-pro/src/main.ts b/demo/image-processing-pro/src/main.ts
new file mode 100644
index 0000000..7a2dd0f
--- /dev/null
+++ b/demo/image-processing-pro/src/main.ts
@@ -0,0 +1,158 @@
+import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
+import vertexShaderSource from './vertex.glsl';
+import fragmentShaderSource from './fragment.glsl';
+import imageSource from './leaves.jpg';
+
+const canvas = document.getElementById('canvas') as HTMLCanvasElement;
+const gl = canvas.getContext('webgl2')!;
+
+resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
+gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+gl.clearColor(0, 0, 0, 0);
+gl.clear(gl.COLOR_BUFFER_BIT);
+
+const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
+gl.useProgram(program);
+
+const vao = gl.createVertexArray();
+gl.bindVertexArray(vao);
+
+const image = await loadImage(imageSource);
+
+const positionLocation = gl.getAttribLocation(program, 'a_position');
+gl.enableVertexAttribArray(positionLocation);
+const positionBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+const positions = [
+  0,
+  0,
+  0,
+  image.height,
+  image.width,
+  0,
+  image.width,
+  0,
+  0,
+  image.height,
+  image.width,
+  image.height,
+];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
+
+const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
+gl.enableVertexAttribArray(texCoordLocation);
+const texCoordBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
+const texCoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
+gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
+
+const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+
+const imageLocation = gl.getUniformLocation(program, 'u_image');
+gl.uniform1i(imageLocation, 0);
+
+const originalTexture = createAndSetupTexture();
+gl.activeTexture(gl.TEXTURE0);
+gl.bindTexture(gl.TEXTURE_2D, originalTexture);
+gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
+
+const textures: WebGLTexture[] = [];
+const framebuffers: WebGLFramebuffer[] = [];
+for (let i = 0; i < 2; i++) {
+  const texture = createAndSetupTexture()!;
+  textures.push(texture);
+  gl.texImage2D(
+    gl.TEXTURE_2D,
+    0,
+    gl.RGBA,
+    image.width,
+    image.height,
+    0,
+    gl.RGBA,
+    gl.UNSIGNED_BYTE,
+    null,
+  );
+
+  const fbo = gl.createFramebuffer()!;
+  framebuffers.push(fbo);
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
+
+  const attachmentPoint = gl.COLOR_ATTACHMENT0;
+  gl.framebufferTexture2D(
+    gl.FRAMEBUFFER,
+    attachmentPoint,
+    gl.TEXTURE_2D,
+    texture,
+    0,
+  );
+}
+
+const kernels: Record<string, number[]> = {
+  normal: [0, 0, 0, 0, 1, 0, 0, 0, 0],
+  gaussianBlur: [0.045, 0.122, 0.045, 0.122, 0.332, 0.122, 0.045, 0.122, 0.045],
+  unsharpen: [-1, -1, -1, -1, 9, -1, -1, -1, -1],
+  emboss: [-2, -1, 0, -1, 1, 1, 0, 1, 2],
+};
+
+const kernelLocation = gl.getUniformLocation(program, 'u_kernel[0]');
+const kernelWeightLocation = gl.getUniformLocation(program, 'u_kernelWeight');
+
+drawEffects();
+
+function loadImage(imageSource: string) {
+  const image = new Image();
+  image.src = imageSource;
+  return new Promise<HTMLImageElement>((resolve, reject) => {
+    image.onload = () => resolve(image);
+    image.onerror = () => reject();
+  });
+}
+
+function createAndSetupTexture() {
+  const texture = gl.createTexture();
+  gl.bindTexture(gl.TEXTURE_2D, texture);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+  return texture;
+}
+
+function drawEffects() {
+  const effects: string[] = [];
+  let count = 0;
+  for (let i = 0; i < effects.length; i++) {
+    setFrameBuffer(framebuffers[count % 2], image.width, image.height);
+    drawWithKernel(effects[i]);
+    gl.bindTexture(gl.TEXTURE_2D, textures[count % 2]);
+    count += 1;
+  }
+  setFrameBuffer(null, gl.canvas.width, gl.canvas.height);
+  drawWithKernel('normal');
+}
+
+function setFrameBuffer(
+  fbo: WebGLFramebuffer | null,
+  width: number,
+  height: number,
+) {
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
+  gl.uniform2f(resolutionLocation, width, height);
+  gl.viewport(0, 0, width, height);
+}
+
+function drawWithKernel(name: string) {
+  const kernel = kernels[name];
+  gl.uniform1fv(kernelLocation, kernel);
+  gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernel));
+  gl.drawArrays(gl.TRIANGLES, 0, 6);
+}
+
+function computeKernelWeight(kernel: number[]) {
+  const weight = kernel.reduce((sum, value) => sum + value, 0);
+  return weight <= 0 ? 1 : weight;
+}
diff --git a/demo/image-processing-pro/src/vertex.glsl b/demo/image-processing-pro/src/vertex.glsl
new file mode 100644
index 0000000..676054b
--- /dev/null
+++ b/demo/image-processing-pro/src/vertex.glsl
@@ -0,0 +1,17 @@
+#version 300 es
+
+in vec4 a_position;
+in vec2 a_texCoord;
+
+uniform vec2 u_resolution;
+
+out vec2 v_texCoord;
+
+void main() {
+  vec2 zeroToOne = a_position.xy / u_resolution;
+  vec2 zeroToTwo = zeroToOne * 2.0;
+  vec2 clipSpace = zeroToTwo - 1.0;
+  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
+
+  v_texCoord = a_texCoord;
+}
\ No newline at end of file
diff --git a/demo/image-processing/index.html b/demo/image-processing/index.html
new file mode 100644
index 0000000..8ce004e
--- /dev/null
+++ b/demo/image-processing/index.html
@@ -0,0 +1,17 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Simple Texture</title>
+    <link rel="stylesheet" href="/common/style.css" />
+  </head>
+  <body>
+    <div id="app">
+      <canvas id="canvas"></canvas>
+    </div>
+    <script type="module" src="/common/home.ts"></script>
+    <script type="module" src="./src/main.ts"></script>
+  </body>
+</html>
diff --git a/demo/image-processing/src/fragment.glsl b/demo/image-processing/src/fragment.glsl
new file mode 100644
index 0000000..fad10b7
--- /dev/null
+++ b/demo/image-processing/src/fragment.glsl
@@ -0,0 +1,28 @@
+#version 300 es
+
+precision highp float;
+
+uniform sampler2D u_image;
+uniform float u_kernel[9];
+uniform float u_kernelWeight;
+
+in vec2 v_texCoord;
+
+out vec4 outColor;
+
+void main() {
+  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));
+
+  vec4 colorSum = 
+    texture(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +
+    texture(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +
+    texture(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +
+    texture(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +
+    texture(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;
+
+  outColor = vec4((colorSum / u_kernelWeight).rgb, 1);
+}
diff --git a/demo/image-processing/src/leaves.jpg b/demo/image-processing/src/leaves.jpg
new file mode 100644
index 0000000..529b94e
Binary files /dev/null and b/demo/image-processing/src/leaves.jpg differ
diff --git a/demo/image-processing/src/main.ts b/demo/image-processing/src/main.ts
new file mode 100644
index 0000000..e9fe6a6
--- /dev/null
+++ b/demo/image-processing/src/main.ts
@@ -0,0 +1,88 @@
+import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
+import vertexShaderSource from './vertex.glsl';
+import fragmentShaderSource from './fragment.glsl';
+import imageSource from './leaves.jpg';
+
+const canvas = document.getElementById('canvas') as HTMLCanvasElement;
+const gl = canvas.getContext('webgl2')!;
+
+resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
+gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+gl.clearColor(0, 0, 0, 0);
+gl.clear(gl.COLOR_BUFFER_BIT);
+
+const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
+gl.useProgram(program);
+
+const vao = gl.createVertexArray();
+gl.bindVertexArray(vao);
+
+const image = await loadImage(imageSource);
+
+const positionLocation = gl.getAttribLocation(program, 'a_position');
+gl.enableVertexAttribArray(positionLocation);
+const positionBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+const positions = [
+  0,
+  0,
+  0,
+  image.height,
+  image.width,
+  0,
+  image.width,
+  0,
+  0,
+  image.height,
+  image.width,
+  image.height,
+];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
+
+const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
+gl.enableVertexAttribArray(texCoordLocation);
+const texCoordBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
+const texCoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
+gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
+
+const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+
+const imageLocation = gl.getUniformLocation(program, 'u_image');
+gl.uniform1i(imageLocation, 0);
+
+const texture = gl.createTexture();
+gl.activeTexture(gl.TEXTURE0);
+gl.bindTexture(gl.TEXTURE_2D, texture);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
+
+const kernelLocation = gl.getUniformLocation(program, 'u_kernel[0]');
+const edgeDetectKernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
+gl.uniform1fv(kernelLocation, edgeDetectKernel);
+
+const kernelWeightLocation = gl.getUniformLocation(program, 'u_kernelWeight');
+gl.uniform1f(kernelWeightLocation, computeKernelWeight(edgeDetectKernel));
+
+gl.drawArrays(gl.TRIANGLES, 0, 6);
+
+function loadImage(imageSource: string) {
+  const image = new Image();
+  image.src = imageSource;
+  return new Promise<HTMLImageElement>((resolve, reject) => {
+    image.onload = () => resolve(image);
+    image.onerror = () => reject();
+  });
+}
+
+function computeKernelWeight(kernel: number[]) {
+  const weight = kernel.reduce((sum, value) => sum + value, 0);
+  return weight <= 0 ? 1 : weight;
+}
diff --git a/demo/image-processing/src/vertex.glsl b/demo/image-processing/src/vertex.glsl
new file mode 100644
index 0000000..676054b
--- /dev/null
+++ b/demo/image-processing/src/vertex.glsl
@@ -0,0 +1,17 @@
+#version 300 es
+
+in vec4 a_position;
+in vec2 a_texCoord;
+
+uniform vec2 u_resolution;
+
+out vec2 v_texCoord;
+
+void main() {
+  vec2 zeroToOne = a_position.xy / u_resolution;
+  vec2 zeroToTwo = zeroToOne * 2.0;
+  vec2 clipSpace = zeroToTwo - 1.0;
+  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
+
+  v_texCoord = a_texCoord;
+}
\ No newline at end of file
diff --git a/demo/random-rectangle/index.html b/demo/random-rectangle/index.html
index 8d16669..9ea0e81 100644
--- a/demo/random-rectangle/index.html
+++ b/demo/random-rectangle/index.html
@@ -5,6 +5,7 @@
     <link rel="icon" type="image/svg+xml" href="/icon.svg" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>WebGl Fundamental</title>
+    <link rel="stylesheet" href="/common/style.css" />
   </head>
   <body>
     <div id="app">
diff --git a/demo/random-rectangle/src/main.ts b/demo/random-rectangle/src/main.ts
index cde224c..c22e162 100644
--- a/demo/random-rectangle/src/main.ts
+++ b/demo/random-rectangle/src/main.ts
@@ -1,4 +1,3 @@
-import '/common/style.css';
 import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
 import vertexShaderSource from './vertex.glsl';
 import fragmentShaderSource from './fragment.glsl';
@@ -15,16 +14,14 @@ gl.clear(gl.COLOR_BUFFER_BIT);
 const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
 gl.useProgram(program);
 
-const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
-gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
-
 const vao = gl.createVertexArray();
 gl.bindVertexArray(vao);
+
 const positionLocation = gl.getAttribLocation(program, 'a_position');
 gl.enableVertexAttribArray(positionLocation);
-const positionBuffer = gl.createBuffer();
-gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
-gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
+
+const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
 
 const colorLocation = gl.getUniformLocation(program, 'u_color');
 
@@ -33,11 +30,14 @@ for (let i = 0; i < 50; i++) {
   const y0 = Math.random() * gl.canvas.height;
   const x1 = Math.random() * gl.canvas.width;
   const y1 = Math.random() * gl.canvas.height;
+  const positionBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
   gl.bufferData(
     gl.ARRAY_BUFFER,
     new Float32Array([x0, y0, x0, y1, x1, y0, x0, y1, x1, y1, x1, y0]),
     gl.STATIC_DRAW,
   );
+  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
   gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);
   gl.drawArrays(gl.TRIANGLES, 0, 6);
 }
diff --git a/demo/simple-texture/index.html b/demo/simple-texture/index.html
new file mode 100644
index 0000000..8ce004e
--- /dev/null
+++ b/demo/simple-texture/index.html
@@ -0,0 +1,17 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Simple Texture</title>
+    <link rel="stylesheet" href="/common/style.css" />
+  </head>
+  <body>
+    <div id="app">
+      <canvas id="canvas"></canvas>
+    </div>
+    <script type="module" src="/common/home.ts"></script>
+    <script type="module" src="./src/main.ts"></script>
+  </body>
+</html>
diff --git a/demo/simple-texture/src/fragment.glsl b/demo/simple-texture/src/fragment.glsl
new file mode 100644
index 0000000..7cd40de
--- /dev/null
+++ b/demo/simple-texture/src/fragment.glsl
@@ -0,0 +1,13 @@
+#version 300 es
+
+precision highp float;
+
+uniform sampler2D u_image;
+
+in vec2 v_texCoord;
+
+out vec4 outColor;
+
+void main() {
+  outColor = texture(u_image, v_texCoord);
+}
diff --git a/demo/simple-texture/src/leaves.jpg b/demo/simple-texture/src/leaves.jpg
new file mode 100644
index 0000000..529b94e
Binary files /dev/null and b/demo/simple-texture/src/leaves.jpg differ
diff --git a/demo/simple-texture/src/main.ts b/demo/simple-texture/src/main.ts
new file mode 100644
index 0000000..f38d611
--- /dev/null
+++ b/demo/simple-texture/src/main.ts
@@ -0,0 +1,80 @@
+import { resizeCanavsToDisplaySize, createProgram } from '@/common/helper';
+import vertexShaderSource from './vertex.glsl';
+import fragmentShaderSource from './fragment.glsl';
+import imageSource from './leaves.jpg';
+
+const canvas = document.getElementById('canvas') as HTMLCanvasElement;
+const gl = canvas.getContext('webgl2')!;
+
+resizeCanavsToDisplaySize(gl.canvas as HTMLCanvasElement);
+gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+gl.clearColor(0, 0, 0, 0);
+gl.clear(gl.COLOR_BUFFER_BIT);
+
+const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
+gl.useProgram(program);
+
+const vao = gl.createVertexArray();
+gl.bindVertexArray(vao);
+
+const image = await loadImage(imageSource);
+
+const positionLocation = gl.getAttribLocation(program, 'a_position');
+gl.enableVertexAttribArray(positionLocation);
+const positionBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+const positions = [
+  0,
+  0,
+  0,
+  image.height,
+  image.width,
+  0,
+  image.width,
+  0,
+  0,
+  image.height,
+  image.width,
+  image.height,
+];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
+gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
+
+const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
+gl.enableVertexAttribArray(texCoordLocation);
+const texCoordBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
+const texCoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];
+gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
+gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
+
+const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+
+const imageLocation = gl.getUniformLocation(program, 'u_image');
+// Tell the shader to get the texture from texture unit-0.
+gl.uniform1i(imageLocation, 0);
+
+// Create a texture.
+const texture = gl.createTexture();
+// Make unit-0 the active texture unit.
+gl.activeTexture(gl.TEXTURE0);
+// Bind it to texture unit-0's 2D bind point.
+gl.bindTexture(gl.TEXTURE_2D, texture);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
+
+gl.drawArrays(gl.TRIANGLES, 0, 6);
+
+function loadImage(imageSource: string) {
+  const image = new Image();
+  image.src = imageSource;
+  return new Promise<HTMLImageElement>((resolve, reject) => {
+    image.onload = () => resolve(image);
+    image.onerror = () => reject();
+  });
+}
diff --git a/demo/simple-texture/src/vertex.glsl b/demo/simple-texture/src/vertex.glsl
new file mode 100644
index 0000000..676054b
--- /dev/null
+++ b/demo/simple-texture/src/vertex.glsl
@@ -0,0 +1,17 @@
+#version 300 es
+
+in vec4 a_position;
+in vec2 a_texCoord;
+
+uniform vec2 u_resolution;
+
+out vec2 v_texCoord;
+
+void main() {
+  vec2 zeroToOne = a_position.xy / u_resolution;
+  vec2 zeroToTwo = zeroToOne * 2.0;
+  vec2 clipSpace = zeroToTwo - 1.0;
+  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
+
+  v_texCoord = a_texCoord;
+}
\ No newline at end of file
diff --git a/env.d.ts b/env.d.ts
index fa0c7d4..3c3a828 100644
--- a/env.d.ts
+++ b/env.d.ts
@@ -1,3 +1,5 @@
+/// <reference types="vite/client" />
+
 declare module '*.glsl' {
   const content: string;
   export default content;
diff --git a/index.html b/index.html
index 8ab5b80..d0fc657 100644
--- a/index.html
+++ b/index.html
@@ -18,6 +18,15 @@
         <li>
           <a href="/demo/gradiant-triangle/">Gradiant Triangle</a>
         </li>
+        <li>
+          <a href="/demo/simple-texture/">Simple Texture</a>
+        </li>
+        <li>
+          <a href="/demo/image-processing/">Image Processing</a>
+        </li>
+        <li>
+          <a href="/demo/image-processing-pro/">Image Processing Pro</a>
+        </li>
       </ul>
     </div>
   </body>
